{
  "id": "msg_01MAi7nVcrpbZAEYstNRq37T",
  "content": [
    {
      "text": "# cut command\n\nExtract selected portions of each line from files.\n\n## Overview\n\nThe `cut` command extracts sections from each line of input files or standard input. It can select parts of text by character position, byte position, or delimiter-separated fields. This command is particularly useful for processing structured text files like CSV or TSV files, or for extracting specific columns from command output.\n\n## Options\n\n### **-b, --bytes=LIST**\n\nExtract specific bytes from each line according to LIST.\n\n```console\n$ echo \"Hello\" | cut -b 1-3\nHel\n```\n\n### **-c, --characters=LIST**\n\nExtract specific characters from each line according to LIST.\n\n```console\n$ echo \"Hello\" | cut -c 2-4\nell\n```\n\n### **-d, --delimiter=DELIM**\n\nUse DELIM as the field delimiter character instead of the default tab.\n\n```console\n$ echo \"name,age,city\" | cut -d, -f2\nage\n```\n\n### **-f, --fields=LIST**\n\nSelect only the specified fields from each line.\n\n```console\n$ echo \"name:age:city\" | cut -d: -f1,3\nname:city\n```\n\n### **-s, --only-delimited**\n\nDo not print lines that do not contain the delimiter character.\n\n```console\n$ printf \"field1,field2,field3\\nno delimiter here\\nA,B,C\" | cut -d, -f1 -s\nfield1\nA\n```\n\n### **--complement**\n\nComplement the set of selected bytes, characters, or fields.\n\n```console\n$ echo \"field1,field2,field3\" | cut -d, -f1 --complement\nfield2,field3\n```\n\n### **--output-delimiter=STRING**\n\nUse STRING as the output delimiter instead of the input delimiter.\n\n```console\n$ echo \"field1,field2,field3\" | cut -d, -f1,3 --output-delimiter=\" | \"\nfield1 | field3\n```\n\n## Usage Examples\n\n### Extract specific columns from CSV file\n\n```console\n$ cat data.csv\nName,Age,City\nJohn,25,New York\nAlice,30,London\n$ cut -d, -f1,3 data.csv\nName,City\nJohn,New York\nAlice,London\n```\n\n### Extract a range of characters from each line\n\n```console\n$ cat file.txt\nThis is a test file\nAnother line of text\n$ cut -c 1-10 file.txt\nThis is a \nAnother li\n```\n\n### Extract multiple ranges of characters\n\n```console\n$ echo \"abcdefghijklmnopqrstuvwxyz\" | cut -c 1-5,10-15\nabcdeijklmn\n```\n\n### Using cut with other commands\n\n```console\n$ ps aux | cut -c 1-10,42-50\nUSER       PID\nroot       1\nuser       435\n```\n\n## Tips:\n\n### Handling Missing Fields\n\nWhen using `-f` with a delimiter, lines without the delimiter won't be processed by default. Use `-s` to skip these lines or omit it to process all lines.\n\n### Working with Fixed-Width Files\n\nFor fixed-width files where columns are aligned by spaces, use `-c` (character positions) rather than `-f` (fields).\n\n### Combining with Other Commands\n\n`cut` works well in pipelines with commands like `grep`, `sort`, and `awk`. For example, `grep \"pattern\" file.txt | cut -d, -f2,3` extracts specific fields from matching lines.\n\n### Handling Special Delimiters\n\nWhen using special characters as delimiters (like space), escape them or use quotes: `cut -d' ' -f1` or `cut -d\" \" -f1`.\n\n## Frequently Asked Questions\n\n#### Q1. How do I extract multiple fields that aren't consecutive?\nA. Use a comma to separate field numbers: `cut -d, -f1,3,5 file.csv`\n\n#### Q2. Can cut handle multi-character delimiters?\nA. No, `cut` only supports single-character delimiters. For multi-character delimiters, consider using `awk` instead.\n\n#### Q3. How do I extract everything except certain fields?\nA. Use the `--complement` option: `cut -d, -f2 --complement file.csv` extracts all fields except the second one.\n\n#### Q4. Why doesn't cut work with my space-delimited file?\nA. Space-delimited files often have variable numbers of spaces. Consider using `awk` for more flexible field separation.\n\n## References\n\nhttps://www.gnu.org/software/coreutils/manual/html_node/cut-invocation.html\n\n## Revisions\n\n- 2025/05/05 First revision",
      "type": "text"
    }
  ],
  "model": "claude-3-7-sonnet-20250219",
  "role": "assistant",
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "type": "message",
  "usage": {
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "input_tokens": 1678,
    "output_tokens": 1120
  }
}