{
  "id": "msg_01E62A5TbbojsXU1LsaqqGFD",
  "content": [
    {
      "text": "# docker コマンド\n\nDockerコンテナ、イメージ、ネットワーク、ボリュームを管理します。\n\n## 概要\n\nDockerは、コンテナ化を使用してアプリケーションとその依存関係を分離されたユニットにパッケージ化するプラットフォームです。`docker`コマンドは、コンテナ、イメージ、ネットワーク、ボリュームを構築、実行、管理するためのCLIを提供します。これにより、開発者は異なるマシン間で一貫した環境を作成できます。\n\n## オプション\n\n### **--help**\n\nDockerコマンドのヘルプ情報を表示します。\n\n```console\n$ docker --help\nUsage:  docker [OPTIONS] COMMAND\n\nコンテナのための自己完結型ランタイム\n\n一般的なコマンド:\n  run         イメージから新しいコンテナを作成して実行する\n  exec        実行中のコンテナでコマンドを実行する\n  ps          コンテナを一覧表示する\n  build       Dockerfileからイメージをビルドする\n  pull        レジストリからイメージをダウンロードする\n  push        イメージをレジストリにアップロードする\n  images      イメージを一覧表示する\n  login       レジストリにログインする\n  logout      レジストリからログアウトする\n  search      Docker Hubでイメージを検索する\n  version     Dockerのバージョン情報を表示する\n  info        システム全体の情報を表示する\n\n管理コマンド:\n  builder     ビルドを管理する\n  buildx*     Docker Buildx (Docker Inc., v0.10.4)\n  compose*    Docker Compose (Docker Inc., v2.17.2)\n  container   コンテナを管理する\n  context     コンテキストを管理する\n  image       イメージを管理する\n  manifest    Dockerイメージマニフェストとマニフェストリストを管理する\n  network     ネットワークを管理する\n  plugin      プラグインを管理する\n  system      Dockerを管理する\n  trust       Dockerイメージの信頼を管理する\n  volume      ボリュームを管理する\n\n[...]\n```\n\n## 使用例\n\n### コンテナの実行\n\n```console\n$ docker run -d -p 80:80 --name webserver nginx\ne5d40ecd5de98d0bff8f57c4d7f1e2f132b95b5bd4c42d8f4e9f659d3e3950cd\n```\n\n### 実行中のコンテナの一覧表示\n\n```console\n$ docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES\ne5d40ecd5de9   nginx     \"/docker-entrypoint.…\"   10 seconds ago   Up 9 seconds    0.0.0.0:80->80/tcp, :::80->80/tcp   webserver\n```\n\n### Dockerfileからイメージをビルドする\n\n```console\n$ docker build -t myapp:1.0 .\n[+] Building 10.5s (10/10) FINISHED\n => [internal] load build definition from Dockerfile                                                 0.1s\n => => transferring dockerfile: 215B                                                                0.0s\n => [internal] load .dockerignore                                                                    0.0s\n => => transferring context: 2B                                                                      0.0s\n => [internal] load metadata for docker.io/library/node:14                                           1.2s\n => [1/5] FROM docker.io/library/node:14@sha256:a158d3b9b4e3fa813fa6c8c590b8f0a860e015ad4e59bbce5744d5dc65798060  0.0s\n => [internal] load build context                                                                    0.0s\n => => transferring context: 32B                                                                     0.0s\n => CACHED [2/5] WORKDIR /app                                                                        0.0s\n => [3/5] COPY package*.json ./                                                                      0.1s\n => [4/5] RUN npm install                                                                            8.5s\n => [5/5] COPY . .                                                                                   0.1s\n => exporting to image                                                                               0.4s\n => => exporting layers                                                                              0.4s\n => => writing image sha256:d64d6b95f5b7e8c3e92a6c2f5f154610e2aa0163d3c1a9c832b80ed4d5a0e21e       0.0s\n => => naming to docker.io/library/myapp:1.0                                                         0.0s\n```\n\n### コンテナの停止\n\n```console\n$ docker stop webserver\nwebserver\n```\n\n### コンテナの削除\n\n```console\n$ docker rm webserver\nwebserver\n```\n\n## ヒント\n\n### マルチコンテナアプリケーションにはDocker Composeを使用する\n\n複数のサービスを持つアプリケーションでは、`docker run`コマンドで各コンテナを個別に管理するのではなく、`docker-compose.yml`ファイルを使用したDocker Composeを使用しましょう。\n\n### 未使用のリソースをクリーンアップする\n\n`docker system prune`を使用して、停止したすべてのコンテナ、未使用のネットワーク、ダングリングイメージ、ビルドキャッシュを削除します。`-a`フラグを追加すると、未使用のイメージもすべて削除されます。\n\n### 永続データには名前付きボリュームを使用する\n\nバインドマウントを使用する代わりに、コンテナの再起動間で永続化する必要があるデータには名前付きボリュームを使用します：`docker run -v mydata:/app/data myapp`\n\n### マルチステージビルドを使用する\n\nより小さな本番用イメージを作成するには、Dockerfileでマルチステージビルドを使用して、ビルド依存関係とランタイム依存関係を分離します。\n\n## よくある質問\n\n#### Q1. `docker run`と`docker start`の違いは何ですか？\nA. `docker run`はイメージから新しいコンテナを作成して起動しますが、`docker start`は既に存在する停止中のコンテナを再起動します。\n\n#### Q2. 実行中のコンテナのシェルにアクセスするにはどうすればよいですか？\nA. `docker exec -it コンテナ名 /bin/bash`または`/bin/sh`を使用して、実行中のコンテナ内でインタラクティブなシェルを取得します。\n\n#### Q3. コンテナのログを表示するにはどうすればよいですか？\nA. `docker logs コンテナ名`を使用してコンテナのログを表示します。リアルタイムでログ出力を追跡するには`-f`を追加します。\n\n#### Q4. ホストとコンテナ間でファイルをコピーするにはどうすればよいですか？\nA. ホストからコンテナにコピーするには`docker cp /ホスト/パス コンテナ名:/コンテナ/パス`を使用し、コンテナからホストにコピーするには`docker cp コンテナ名:/コンテナ/パス /ホスト/パス`を使用します。\n\n#### Q5. 実行中のコンテナの設定を更新するにはどうすればよいですか？\nA. 実行中のコンテナのほとんどの設定オプションは更新できません。代わりに、コンテナを停止し、削除して、更新された設定で新しいコンテナを作成します。\n\n## 参考文献\n\nhttps://docs.docker.com/engine/reference/commandline/docker/\n\n## 改訂履歴\n\n- 2025/05/05 初版",
      "type": "text"
    }
  ],
  "model": "claude-3-7-sonnet-20250219",
  "role": "assistant",
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "type": "message",
  "usage": {
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "input_tokens": 1646,
    "output_tokens": 2243
  }
}