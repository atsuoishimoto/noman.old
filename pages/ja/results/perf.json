{
  "id": "msg_013Rd3JnjAafUW8St39zYVpv",
  "content": [
    {
      "text": "# perfコマンド\n\nLinuxのパフォーマンス分析ツールで、ハードウェアカウンタの統計情報やトレース機能を提供します。\n\n## 概要\n\n`perf`は、CPUのパフォーマンスモニタリングハードウェアカウンタにアクセスしてプログラム実行に関する統計情報を収集する、強力なLinuxプロファイリングツールです。CPUパフォーマンスイベントのモニタリング、システムコールのトレース、アプリケーションのプロファイリング、ハードウェアおよびソフトウェアイベントの分析が可能です。Linuxカーネルツールの一部であり、アプリケーションやシステムのパフォーマンスボトルネックを特定するのに役立ちます。\n\n## オプション\n\n### **stat**\n\nコマンドを実行し、パフォーマンスカウンタの統計情報を収集します\n\n```console\n$ perf stat ls\nDocuments  Downloads  Pictures  Videos\n\n Performance counter stats for 'ls':\n\n              0.93 msec task-clock                #    0.781 CPUs utilized          \n                 0      context-switches          #    0.000 K/sec                  \n                 0      cpu-migrations            #    0.000 K/sec                  \n                89      page-faults               #    0.096 M/sec                  \n           1,597,086      cycles                  #    1.724 GHz                    \n           1,221,363      instructions            #    0.76  insn per cycle         \n             245,931      branches                #  265.518 M/sec                  \n              10,764      branch-misses           #    4.38% of all branches        \n\n       0.001189061 seconds time elapsed\n\n       0.001090000 seconds user\n       0.000000000 seconds sys\n```\n\n### **record**\n\n後の分析のためにパフォーマンスデータを記録します\n\n```console\n$ perf record -g ./myprogram\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.064 MB perf.data (1302 samples) ]\n```\n\n### **report**\n\n以前の記録からパフォーマンスデータを表示します\n\n```console\n$ perf report\n# Samples: 1302\n#\n# Overhead  Command      Shared Object        Symbol\n# ........  .......  .................  ..............\n#\n    35.71%  myprogram  myprogram           [.] process_data\n    24.58%  myprogram  libc-2.31.so        [.] malloc\n    15.21%  myprogram  myprogram           [.] calculate_result\n```\n\n### **top**\n\nLinuxのシステムプロファイリングツールで、topに似ていますがパフォーマンスカウンタ情報を含みます\n\n```console\n$ perf top\nSamples: 42K of event 'cycles', 4000 Hz, Event count (approx.): 10456889073\nOverhead  Shared Object                       Symbol\n  12.67%  [kernel]                            [k] _raw_spin_unlock_irqrestore\n   4.71%  [kernel]                            [k] finish_task_switch\n   2.82%  [kernel]                            [k] __schedule\n   2.40%  firefox                             [.] 0x00000000022e002d\n```\n\n### **list**\n\nモニタリング可能なイベントを一覧表示します\n\n```console\n$ perf list\nList of pre-defined events (to be used in -e):\n\n  cpu-cycles OR cycles                               [Hardware event]\n  instructions                                       [Hardware event]\n  cache-references                                   [Hardware event]\n  cache-misses                                       [Hardware event]\n  branch-instructions OR branches                    [Hardware event]\n  branch-misses                                      [Hardware event]\n  ...\n```\n\n### **-e, --event**\n\nモニタリングするイベントを指定します（他のコマンドと共に使用）\n\n```console\n$ perf stat -e cycles,instructions,cache-misses ./myprogram\n Performance counter stats for './myprogram':\n\n     1,234,567,890      cycles\n       987,654,321      instructions              #    0.80  insn per cycle\n         5,432,109      cache-misses\n\n       1.234567890 seconds time elapsed\n```\n\n### **-p, --pid**\n\nPIDで特定のプロセスをモニタリングします\n\n```console\n$ perf record -p 1234\n^C[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.452 MB perf.data (2371 samples) ]\n```\n\n### **-g, --call-graph**\n\nコールグラフ（スタックチェーン/バックトレース）の記録を有効にします\n\n```console\n$ perf record -g ./myprogram\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.128 MB perf.data (2567 samples) ]\n```\n\n## 使用例\n\n### コマンドのCPU使用状況のプロファイリング\n\n```console\n$ perf stat -d ls -la\ntotal 56\ndrwxr-xr-x  9 user user 4096 May  5 10:00 .\ndrwxr-xr-x 28 user user 4096 May  4 15:30 ..\n-rw-r--r--  1 user user 8980 May  5 09:45 file.txt\n\n Performance counter stats for 'ls -la':\n\n              1.52 msec task-clock                #    0.812 CPUs utilized          \n                 0      context-switches          #    0.000 K/sec                  \n                 0      cpu-migrations            #    0.000 K/sec                  \n               102      page-faults               #    0.067 M/sec                  \n         3,842,901      cycles                    #    2.530 GHz                    \n         5,779,212      instructions              #    1.50  insn per cycle         \n         1,059,631      branches                  #  697.128 M/sec                  \n            36,789      branch-misses             #    3.47% of all branches        \n         1,254,898      L1-dcache-loads           #  825.590 M/sec                  \n            45,632      L1-dcache-load-misses     #    3.64% of all L1-dcache accesses\n\n       0.001871938 seconds time elapsed\n\n       0.001871000 seconds user\n       0.000000000 seconds sys\n```\n\n### アプリケーションパフォーマンスの記録と分析\n\n```console\n$ perf record -g ./myapplication\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.253 MB perf.data (3842 samples) ]\n\n$ perf report\n# To display the perf.data header info, please use --header/--header-only options.\n#\n# Samples: 3K of event 'cycles'\n# Event count (approx.): 3842000000\n#\n# Overhead  Command        Shared Object        Symbol\n# ........  .......  .................  ..............\n#\n    35.42%  myapplication  myapplication        [.] process_data\n    21.67%  myapplication  libc-2.31.so         [.] malloc\n    15.89%  myapplication  myapplication        [.] calculate_result\n```\n\n### 特定のハードウェアイベントのモニタリング\n\n```console\n$ perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores ./myprogram\n Performance counter stats for './myprogram':\n\n       123,456,789      L1-dcache-loads\n         2,345,678      L1-dcache-load-misses     #    1.90% of all L1-dcache accesses\n        98,765,432      L1-dcache-stores\n\n       2.345678901 seconds time elapsed\n```\n\n## ヒント:\n\n### 完全なアクセスのためにrootとして実行\n\n多くのperf機能はroot権限を必要とします。すべてのハードウェアカウンタとシステム全体のプロファイリング機能にアクセスするには、`sudo perf`を使用してください。\n\n### 視覚化のためにフレームグラフを使用\n\n分析を容易にするために、perfデータをフレームグラフに変換します：\n```console\n$ perf record -g ./myprogram\n$ perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl > flamegraph.svg\n```\n\n### ホットスポットに集中\n\nパフォーマンスデータを分析する際は、オーバーヘッドの割合が最も高い関数に最初に集中してください。これらは最適化の機会が最も大きい部分です。\n\n### 記録中のオーバーヘッドを削減\n\n本番環境でのプロファイリングでは、`-F`を使用して低い頻度でサンプリングし、パフォーマンスへの影響を減らします：\n```console\n$ perf record -F 99 -g -p 1234\n```\n\n### ソースコードの注釈付け\n\n`perf annotate`を使用して、パフォーマンスの問題を引き起こしている特定のコード行を確認します：\n```console\n$ perf annotate -d ./myprogram\n```\n\n## よくある質問\n\n#### Q1. perf statとperf recordの違いは何ですか？\nA. `perf stat`はコマンド完了後にパフォーマンスメトリクスの要約を提供するのに対し、`perf record`は後で`perf report`で分析できる詳細なパフォーマンスデータを取得します。\n\n#### Q2. 実行中のプロセスをプロファイリングするにはどうすればよいですか？\nA. `perf record -p PID`を使用して、プロセスIDで実行中のプロセスにアタッチします。\n\n#### Q3. perf reportの出力をどのように解釈すればよいですか？\nA. 「Overhead」列は各関数に起因するサンプルの割合を示し、パフォーマンスのボトルネックを特定するのに役立ちます。割合が高いほど、その関数がより多くのCPU時間を消費していることを示します。\n\n#### Q4. perfはGPUパフォーマンスをプロファイリングできますか？\nA. 標準のperfは主にCPUとシステムパフォーマンスに焦点を当てています。GPUプロファイリングには、NVIDIAのnvprofやAMDのROCmプロファイラなどの専用ツールがより適しています。\n\n#### Q5. perf.dataファイルのサイズを小さくするにはどうすればよいですか？\nA. `--freq`または`-F`オプションを使用してサンプリングレートを下げるか、`-a`オプションと時間指定を使用してデータ収集期間を制限します。\n\n## 参考文献\n\nhttps://perf.wiki.kernel.org/index.php/Main_Page\n\n## 改訂履歴\n\n- 2025/05/05 初版",
      "type": "text"
    }
  ],
  "model": "claude-3-7-sonnet-20250219",
  "role": "assistant",
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "type": "message",
  "usage": {
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "input_tokens": 2510,
    "output_tokens": 3103
  }
}