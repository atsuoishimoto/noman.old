{
  "id": "msg_013MCbpjKRH56N5SrHiAvFm2",
  "content": [
    {
      "text": "# perf command\n\nPerformance analysis tool for Linux, providing hardware counter statistics and tracing capabilities.\n\n## Overview\n\n`perf` is a powerful Linux profiling tool that accesses the performance monitoring hardware counters of the CPU to gather statistics about program execution. It can monitor CPU performance events, trace system calls, profile applications, and analyze hardware and software events. Part of the Linux kernel tools, it helps identify performance bottlenecks in applications and the system.\n\n## Options\n\n### **stat**\n\nRuns a command and gathers performance counter statistics\n\n```console\n$ perf stat ls\nDocuments  Downloads  Pictures  Videos\n\n Performance counter stats for 'ls':\n\n              0.93 msec task-clock                #    0.781 CPUs utilized          \n                 0      context-switches          #    0.000 K/sec                  \n                 0      cpu-migrations            #    0.000 K/sec                  \n                89      page-faults               #    0.096 M/sec                  \n           1,597,086      cycles                  #    1.724 GHz                    \n           1,221,363      instructions            #    0.76  insn per cycle         \n             245,931      branches                #  265.518 M/sec                  \n              10,764      branch-misses           #    4.38% of all branches        \n\n       0.001189061 seconds time elapsed\n\n       0.001090000 seconds user\n       0.000000000 seconds sys\n```\n\n### **record**\n\nRecords performance data for later analysis\n\n```console\n$ perf record -g ./myprogram\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.064 MB perf.data (1302 samples) ]\n```\n\n### **report**\n\nDisplays performance data from a previous recording\n\n```console\n$ perf report\n# Samples: 1302\n#\n# Overhead  Command      Shared Object        Symbol\n# ........  .......  .................  ..............\n#\n    35.71%  myprogram  myprogram           [.] process_data\n    24.58%  myprogram  libc-2.31.so        [.] malloc\n    15.21%  myprogram  myprogram           [.] calculate_result\n```\n\n### **top**\n\nSystem profiling tool for Linux, similar to top but with performance counter information\n\n```console\n$ perf top\nSamples: 42K of event 'cycles', 4000 Hz, Event count (approx.): 10456889073\nOverhead  Shared Object                       Symbol\n  12.67%  [kernel]                            [k] _raw_spin_unlock_irqrestore\n   4.71%  [kernel]                            [k] finish_task_switch\n   2.82%  [kernel]                            [k] __schedule\n   2.40%  firefox                             [.] 0x00000000022e002d\n```\n\n### **list**\n\nLists available events for monitoring\n\n```console\n$ perf list\nList of pre-defined events (to be used in -e):\n\n  cpu-cycles OR cycles                               [Hardware event]\n  instructions                                       [Hardware event]\n  cache-references                                   [Hardware event]\n  cache-misses                                       [Hardware event]\n  branch-instructions OR branches                    [Hardware event]\n  branch-misses                                      [Hardware event]\n  ...\n```\n\n### **-e, --event**\n\nSpecifies which events to monitor (used with other commands)\n\n```console\n$ perf stat -e cycles,instructions,cache-misses ./myprogram\n Performance counter stats for './myprogram':\n\n     1,234,567,890      cycles\n       987,654,321      instructions              #    0.80  insn per cycle\n         5,432,109      cache-misses\n\n       1.234567890 seconds time elapsed\n```\n\n### **-p, --pid**\n\nMonitors a specific process by its PID\n\n```console\n$ perf record -p 1234\n^C[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.452 MB perf.data (2371 samples) ]\n```\n\n### **-g, --call-graph**\n\nEnables call-graph (stack chain/backtrace) recording\n\n```console\n$ perf record -g ./myprogram\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.128 MB perf.data (2567 samples) ]\n```\n\n## Usage Examples\n\n### Profiling CPU usage of a command\n\n```console\n$ perf stat -d ls -la\ntotal 56\ndrwxr-xr-x  9 user user 4096 May  5 10:00 .\ndrwxr-xr-x 28 user user 4096 May  4 15:30 ..\n-rw-r--r--  1 user user 8980 May  5 09:45 file.txt\n\n Performance counter stats for 'ls -la':\n\n              1.52 msec task-clock                #    0.812 CPUs utilized          \n                 0      context-switches          #    0.000 K/sec                  \n                 0      cpu-migrations            #    0.000 K/sec                  \n               102      page-faults               #    0.067 M/sec                  \n         3,842,901      cycles                    #    2.530 GHz                    \n         5,779,212      instructions              #    1.50  insn per cycle         \n         1,059,631      branches                  #  697.128 M/sec                  \n            36,789      branch-misses             #    3.47% of all branches        \n         1,254,898      L1-dcache-loads           #  825.590 M/sec                  \n            45,632      L1-dcache-load-misses     #    3.64% of all L1-dcache accesses\n\n       0.001871938 seconds time elapsed\n\n       0.001871000 seconds user\n       0.000000000 seconds sys\n```\n\n### Recording and analyzing application performance\n\n```console\n$ perf record -g ./myapplication\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.253 MB perf.data (3842 samples) ]\n\n$ perf report\n# To display the perf.data header info, please use --header/--header-only options.\n#\n# Samples: 3K of event 'cycles'\n# Event count (approx.): 3842000000\n#\n# Overhead  Command        Shared Object        Symbol\n# ........  .......  .................  ..............\n#\n    35.42%  myapplication  myapplication        [.] process_data\n    21.67%  myapplication  libc-2.31.so         [.] malloc\n    15.89%  myapplication  myapplication        [.] calculate_result\n```\n\n### Monitoring specific hardware events\n\n```console\n$ perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores ./myprogram\n Performance counter stats for './myprogram':\n\n       123,456,789      L1-dcache-loads\n         2,345,678      L1-dcache-load-misses     #    1.90% of all L1-dcache accesses\n        98,765,432      L1-dcache-stores\n\n       2.345678901 seconds time elapsed\n```\n\n## Tips:\n\n### Run as Root for Full Access\n\nMany perf features require root privileges. Use `sudo perf` to access all hardware counters and system-wide profiling capabilities.\n\n### Use Flame Graphs for Visualization\n\nConvert perf data to flame graphs for easier analysis:\n```console\n$ perf record -g ./myprogram\n$ perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl > flamegraph.svg\n```\n\n### Focus on Hotspots\n\nWhen analyzing performance data, concentrate on functions with the highest overhead percentages first, as these represent the best optimization opportunities.\n\n### Reduce Overhead During Recording\n\nFor production profiling, use sampling at a lower frequency with `-F` to reduce the performance impact:\n```console\n$ perf record -F 99 -g -p 1234\n```\n\n### Annotate Source Code\n\nUse `perf annotate` to see which specific lines of code are causing performance issues:\n```console\n$ perf annotate -d ./myprogram\n```\n\n## Frequently Asked Questions\n\n#### Q1. What's the difference between perf stat and perf record?\nA. `perf stat` provides a summary of performance metrics after a command completes, while `perf record` captures detailed performance data that can be analyzed later with `perf report`.\n\n#### Q2. How can I profile a running process?\nA. Use `perf record -p PID` to attach to a running process by its process ID.\n\n#### Q3. How do I interpret the output of perf report?\nA. The \"Overhead\" column shows the percentage of samples attributed to each function, helping identify performance bottlenecks. Higher percentages indicate functions consuming more CPU time.\n\n#### Q4. Can perf profile GPU performance?\nA. Standard perf primarily focuses on CPU and system performance. For GPU profiling, specialized tools like NVIDIA's nvprof or AMD's ROCm profiler are more appropriate.\n\n#### Q5. How can I reduce the size of perf.data files?\nA. Use the `--freq` or `-F` option with a lower sampling rate, or limit the data collection duration with the `-a` option and a time specification.\n\n## References\n\nhttps://perf.wiki.kernel.org/index.php/Main_Page\n\n## Revisions\n\n- 2025/05/05 First revision",
      "type": "text"
    }
  ],
  "model": "claude-3-7-sonnet-20250219",
  "role": "assistant",
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "type": "message",
  "usage": {
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "input_tokens": 4068,
    "output_tokens": 2380
  }
}